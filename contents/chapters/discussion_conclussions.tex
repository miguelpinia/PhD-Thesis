\chapter{Discussion and Conclussions}

This thesis delves into the evolution of concurrent computing and the shift from traditional to more flexible approaches when programming concurrent algorithms. The primary objective of this study was to determine whether it is possible to implement meaningful and useful objects using only synchronization mechanisms among the simplest ones without compromising performance in practical settings.

In Chapter~\ref{chapter:4_work-stealing}, the problem of work-stealing was addressed, and the limits of the standard asynchronous Read/Write wait-free, shared memory model were explored. In Chapter~\ref{chapter:5_modular-basket-queues}, the focus shifted towards building objects from a modular perspective while keeping in mind the use of simple synchronization mechanisms. Specifically, a modular queue was built, where some components can be implemented using only Read/Write operations.


In Chapter~\ref{chapter:6_Results} we present an experimental evaluation to measure the performance of the algorithms presented in Chapters~\ref{chapter:4_work-stealing} and~\ref{chapter:5_modular-basket-queues}. For work-stealing, the study reveals that the use of simple mechanisms can compete and even in some cases, outperform state-of-the-art algorithms. In the case of the modular queue, the study reveals that the queue cannot compete directly against the fastest state-of-the-art queues. However, its performance is good enough, and the performance lies in particular implementations of its modules.

\section{\label{sec:experiment-conclussions} Case Study: Work-Stealing}

In Chapter~\ref{chapter:4_work-stealing}, we studied the use of multiplicity applied to work-stealing. We studied two relaxations for work-stealing, called multiplicity and weak multiplicity. Both of them allow a task to be extracted by more than one $\Take/\Steal$ operation, but each process can take the same task at most once; however, the relaxation can arise only in concurrency. For the first relaxation, this property is directly guaranteed by the definition of set-linearizability. The second relaxation follows from the fact that solutions are required to be sequentially-exact. We presented two $\R/\W$, wait-free algorithms for the relaxations, both devoid of \RAW synchronization patterns.
Moreover, the second algorithm is fence-free with constant step complexity. To our knowledge, these are the first algorithms for relaxations of work-stealing having all these properties, evading the known impossibility result~\cite{DBLP_conf_popl_AttiyaGHKMV11} in all their high-level operations. From the theoretical perspective of the consensus number hierarchy~\cite{DBLP_journals_toplas_Herlihy91}, we have thus shown that work-stealing with multiplicity and weak multiplicity lay at the lowest level with objects whose consensus number is one. We also argued that the idempotent work-stealing~\cite{maged.vechev.2009} does not solve either work-stealing with multiplicity or weak multiplicity. Therefore, the relaxations and algorithms proposed here provide stronger guarantees. An experimental evaluation showed that the benefits in the performance of work-stealing with relaxed semantics depend on the type of application and the complexity of the work associated with a task. Therefore, it cannot be guaranteed that relaxations of work-stealing will always lead to improvements.

Viewed collectively, our results show that the simplest synchronization mechanisms suffice to solve non-trivial coordination problems without compromising performance in some practical applications. We can conclude, that relaxed work-stealing algorithms enhanced performance in the benchmarks with lightweight tasks. In the case of graph exploration, the FIFO insert/extract policy provided better improvements. In the benchmark with heavy tasks, all algorithms performed equally.
%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../../main"
%%% End:
