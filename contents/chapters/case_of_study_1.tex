\chapter{Case Of Study 1: Work-Stealing}

\section{Introduction}

It is known that any algorithm for some concurrent objects must use costly synchronization mechanisms, which might jeopardize performance. Thus, objects with relaxed semantics have been proposed to find algorithms devoid of such costly mechanisms. In this chapter, we explore whether there are non-trivial and useful relaxed objects that can be implemented using only synchronization mechanisms that are among the simplest ones without compromising performance.  We concretely focus on the case of work-stealing.

\subsection{Context}

\emph{Work-stealing} is a popular technique to implement dynamic \emph{load balancing} for efficient task parallelization of irregular workloads. It has been used in several contexts, e.g., programming languages, parallel-programming frameworks, SAT solvers and state-space exploration in model checking (e.g.~\cite{DBLP_journals_tpds_AyguadeCDHLMTUZ09, DBLP_journals_jpdc_BlumofeJKLRZ96, CGSDKEPS05, DBLP_conf_jvm_FloodDSZ01, DBLP_conf_pldi_FrigoLR98, DBLP_conf_java_Lea00, DBLP_conf_hpca_RangerRPBK07}).

In work-stealing, each process \emph{owns} a set of tasks that must be executed.  The \emph{owner} of the set can put tasks in it and can take tasks from it to execute them. When a process runs out of tasks (i.e., the set is empty), it becomes a \emph{thief} to steal tasks from a \emph{victim}. A work-stealing algorithm provides three high-level operations: \Put and \Take, which can be invoked only by the owner, and \Steal, which a thief can invoke. \emph{Linearizability}~\cite{DBLP_journals_toplas_HerlihyW90} is the usual assumed correctness condition, while \emph{nonblockingness}~\cite{DBLP_journals_toplas_HerlihyW90} and the stronger \emph{wait-freedom}~\cite{DBLP_conf_spaa_Herlihy91} are the typical  progress conditions.

A main target when designing work-stealing algorithms is to have \Put and \Take operations as simple and efficient as possible, as typically, they are the operations most intensively used by the owner. Unfortunately, it has been formally shown that any work-stealing algorithm in the standard asynchronous shared memory model must use \RAW synchronization patterns or atomic \RMW instructions (e.g., \CAS or \TAS)~\cite{DBLP_journals_jacm_AttiyaGHK09}. \RAW is a useful synchronization pattern based on the \emph{flag principle}, i.e., writing on a shared variable and then reading another variable (see~\cite {DBLP_books_daglib_0020056}). To correctly implement an algorithm using such a synchronization pattern in real multi-core architectures, a memory \emph{fence} (also called \emph{barrier}) needs to be explicitly added so that the \R and \W instructions are not reordered by the compiler or the architecture.  It is well-known that fences that avoid reads and writes to be reordered are highly costly, while atomic \RMW instructions, with high coordination power (which can be formally measured through the \emph{consensus number} formalism~\cite{DBLP_journals_toplas_Herlihy91}), are in principle slower than the simple \R/\W instructions.\footnote{In practice, contention might be the dominant factor, namely, an uncontended \RMW instruction can be faster than contended \R/\W instructions.} Indeed, the known work-stealing algorithms in the literature are based on the flag principle in their \Take/\Steal operations~\cite{circular.work.stealing, FLR98, non.blocking.work.stealing, 10.1145.571825.571876}.  Two possible ways to circumvent the impossibility result in~\cite{DBLP_journals_jacm_AttiyaGHK09} are to consider work-stealing with relaxed semantics or to make extra assumptions on the model.  As far as we know,~\cite{maged.vechev.2009} and~\cite{fencefreework} are the only works that follow these directions.

Observing that in some contexts, it is ensured that no task is repeated (e.g., by checking first if a task is completed) or the nature of the problem solved tolerates repeatable work (e.g., parallel SAT solvers), Michael, Vechev, and Saraswat propose \emph{idempotent} work-stealing~\cite{maged.vechev.2009}, a relaxation allowing a task to be taken \emph{at least once}, instead of \emph{exactly once}.  Three idempotent work-stealing algorithms are presented in~\cite{maged.vechev.2009}, where tasks are inserted/extracted in different orders.  The relaxation allows each of the algorithms to circumvent the impossibility result in~\cite{DBLP_journals_jacm_AttiyaGHK09} in its \Put and \Take operations as they use only \R/\W instructions and are devoid of \RAW synchronization patterns. However, \Steal uses \CAS. Moreover, \Put requires that some \W instructions are not reordered, and \Steal requires that some \R instructions are not reordered either, and thus fences are required when the algorithms are implemented. Fences between \R (resp. \W) instructions, however, are usually not too costly in practice. As for progress guarantees, \Put and \Take are wait-free while \Steal is only nonblocking.

Morrison and Afek consider the TSO model~\cite{DBLP_journals_cacm_SewellSONM10} and present two work-stealing algorithms in~\cite{fencefreework} whose \Put operation is wait-free and uses only \R/\W instructions,  and \Take and \Steal are either nonblocking and use \CAS, or blocking and use a \emph{lock}.  The algorithms are non-trivial adaptations of the well-known Cilk THE and Chase-Lev work-stealing algorithms~\cite{circular.work.stealing, FLR98} to the TSO model.  Generally speaking, in this model, \W (resp. \R) instructions cannot be reordered; hence, fences among \W (resp. \R) instructions are unnecessary. Additionally, each process has a local buffer where its \W instructions are stored until they are eventually propagated to the main memory (in FIFO order).  Reordering some \W (resp. \R) instructions of Morrison and Afek's algorithms compromises correctness. However, TSO prevents this from happening.  To avoid \RAW patterns, they assume bounded size \W buffers.