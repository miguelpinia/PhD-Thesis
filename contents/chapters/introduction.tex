\chapter{\label{chapter:1_Introduction}Introduction}

These days, it is very common to hear about new processors that increase the number of cores in each one. Tasks like gaming, data processing, rendering animation, and video editions are becoming more natural in the day-to-day. These tasks take advantage of the new processors and their multi-core architectures. It is worth mentioning that these multi-core processors are already present in laptops, smartphones, PCs, tablets, smart TVs, game consoles, multiple IoT\footnote{Internet of the Things.} devices, smartwatches, and even devices like keyboards!\footnote{My current keyboard is already a tiny computing device; it has a small screen on which small applications can be displayed and some additional controls like a knob to use such applications. Regarding the keyboard's processor specification, the provider mentioned that the processor follows a multi-core architecture without specifying which one.} No matter if we are specialized programmers like those who work in embedded systems or we are working on backend software or developing games, it is really important to design and code algorithms that take advantage of these multi-core architectures.

However, concurrent computing is one of the most challenging topics in computer science. This is because we are used to thinking in a sequence of steps. It is not easy to imagine multiple things happening simultaneously and randomly intermixing. When we program sequentially, it is easy to see that things occur in the same order every time, making it deterministic. However, concurrency introduces non-determinism since processes run independently, meaning things do not necessarily happen in the same order. As a result, all kinds of unforeseen interactions can occur. When building concurrent algorithms, some things must be taken into account in the right order to avoid undesirable behaviors in concurrent executions. For example, we can consider the following reasons why concurrent programming can be challenging:

\begin{itemize}
  \item \textbf{Complexity}: Execute concurrent algorithms involve running multiple tasks simultaneously. Such executions can result in complex interactions and interdependencies between different parts of the program. Managing and coordinating all these interactions in a synchronized manner can be quite challenging.
  \item \textbf{Race Conditions}: A race condition occurs when the expected outcome or state of a shared variable relies on a specific sequence of events that are beyond the program's design. Usually, this problem can result in errors, unpredictable behavior, or bugs that are challenging to replicate.
.  \item \textbf{Synchronization}: To ensure that multiple processes can safely access shared resources, synchronization mechanisms such as locks, semaphores, barriers, or even concurrency primitives provided by processor architectures must be used. However, correctly managing these mechanisms can be challenging, as improper use can cause problems such as data corruption or performance issues. Therefore, it is essential to implement these mechanisms correctly to prevent such issues.
  \item \textbf{Performance}: Usually, we think that using multiple cores in parallel should improve the performance of a concurrent program. However, using shared resources and some factors like load balancing, synchronization, and unnecessary parallelization can degrade the performance of concurrent programs. We must carefully design and develop concurrent programs to achieve optimal performance.
  \item \textbf{Deadlocks}: A deadlock happens when two o more processes are waiting for each other to release resources. This results in a state where no process can make any progress. Deadlocks are usually challenging and hard identify and resolve, specially in complex systems
  \item \textbf{Scalability}: We want that our concurrent programs scale well as the number of processors or cores increases. However, ensure that concurrent programs improve when the number of processors increase requires careful design and optimization.
  \item \textbf{Learning Curve}: Additional concepts to sequential programming, like threads, processes, concurrency primitives, linearizability, and sequential consistency can require a significant learning curve.
  \item \textbf{Debugging and Testing}: The concurrent programs' nondeterministic nature makes them difficult to debug. Order-of-events-dependent bugs are also challenging to reproduce and diagnose. Testing such programs can be time-consuming and complex.

\end{itemize}



\section{\label{section:Overview}Overview}
\section{\label{section:Motivation}Motivation}
\section{\label{section:Objectives}Objectives and Contribution}
\section{\label{section:Organization}Organization}
%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../../main"
%%% End:
