% Created 2023-01-26 jue 17:26
% Intended LaTeX compiler: pdflatex
\documentclass[openany, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{amsmath,amssymb,amsthm,geometry,hyperref,paralist,svg,thmtools,tikz,tikz-cd}
\usepackage{mathtools}
\usepackage[capitalise,noabbrev]{cleveref}
\usepackage{mdframed} \usepackage{svg}
\usepackage{environ} \NewEnviron{abmn}{\marginnote{\BODY}}
\usepackage{url}
\usepackage{color}
\usepackage{listings,chngcntr}% http://ctan.org/pkg/listings
\usepackage{multicol}
\usepackage{url}
\usepackage{tabularx}
\lstset{ basicstyle=\ttfamily, mathescape=true, frame=Trbl, numbers=left}
\renewcommand{\lstlistingname}{Pseudocódigo}
\setcounter{tocdepth}{1}
\newtheoremstyle{break}{\topsep}{\topsep}{\itshape}{}{\bfseries}{}{\newline}{}
\theoremstyle{break}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{affirmation}[theorem]{Affirmation}
\theoremstyle{example}
\newtheorem{example}{Example}
\newtheorem{exmpl}{Example}
\theoremstyle{note}
\newtheorem{note}{Note}
\theoremstyle{break}
\newtheorem{remark}{Remark}
\theoremstyle{exercise}
\newtheorem{exercise}{Exercise}
\usetikzlibrary{arrows,automata,positioning}
\NewEnviron{obs}{\begin{mdframed}\begin{remark} \BODY \end{remark}\end{mdframed}}
\NewEnviron{nota}{\begin{mdframed}\begin{note} \BODY \end{note}\end{mdframed}}
\renewcommand{\qedsymbol}{\textbf{\therefore}}
\NewEnviron{blk}{\begin{mdframed}\BODY\end{mdframed}}
\newcommand{\nimplies}{\;\not\nobreak\!\!\!\!\implies}
\AtBeginDocument{\renewcommand{\thelstlisting}{\thesection.\arabic{lstlisting}}}
\AtBeginDocument{\counterwithin{lstlisting}{section}}
\newcommand{\R}{{\sf \small Read}\xspace}
\newcommand{\W}{{\sf \small Write}\xspace}
\author{Miguel Angel Piña Avelino}
\date{\today}
\title{Introduction to multi-threading programming with Java (2 days)}
\hypersetup{
 pdfauthor={Miguel Angel Piña Avelino},
 pdftitle={Introduction to multi-threading programming with Java (2 days)},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.5.5)},
 pdflang={Spanish}}
\begin{document}

\maketitle
\textbf{Prerrequisites}:
\begin{itemize}
\item Maven
\item An editor like emacs or vi or IDE like Netbeans
\item JDK 17 (open-jdk)
\item git
\end{itemize}

\section{Introduction}
\label{sec:orgdc0e1d8}

In the early 2000s, the multicore revolution began due to was difficult make
processor chips smaller and faster. Derived from this situation, we had to
change the way in how we develop software. The multicore chips cause that
perform computing being more effective by exploiting
``parallelism''. However, the challenge is in how to exploit that
parallelism. Those multicore chips or multiprocessors, usually use shared
memory to communicate the processors between themselves, thus, an important
aspect to program these multiprocessors is how to coordinate the access to
shared memory, i.e. how to coordinate the access to some shared data to avoid
problems while it is manipulated (writes and lectures). The above is
challenging due to the modern systems are inherently asynchronous and,
without synchronization mechanisms, unpredictable events can occur while the
shared data is manipulated.

We will focus on tools and techniques for programming multiprocessors using
shared memory with java. We will cover some topics related to concurrent and
parallel computing.

\section{Processes and threads}
\label{sec:org3c8947a}

The first thing that we will talk is what is the difference between a process
and a thread. Both process and thread are independent sequences of
execution. Loosely speaking, a process is in practical terms, an executing
program. A thread is a lightweight process that can run in parallel and share
resources as memory and disc with its parent process. Usually, threads run in
process space context.

For example, we can run a program in java (like an IDE as Netbeans). The
program running is known as the main process, and all those events that
executes asynchronously inside of our program, like invoke to compile the
code, debugging or even library search for our project inside the IDE, are
executed by threads. That's the main difference.

\section{Basics}
\label{sec:org60a6e03}

\textbf{Creating the base project}: Lets create a maven based project. In some
terminal, write:

\begin{verbatim}
cd ..
mvn archetype:generate -DgroupId=mx.unam.concurrent \
    -DartifactId=concurrent-example \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DarchetypeVersion=1.4 -DinteractiveMode=false
ls | grep concurrent-example
\end{verbatim}

It creates a project with a main file called \texttt{App.java}. In that file we
will work with the tools for write multi-threaded applications. The first
thing is change some parameters of our project to work with a recent
java version.

In the file \texttt{pom.xml}, change the target output and compiler version. Those
values should be changed in the properties section.

\begin{verbatim}
<maven.compiler.source>17</maven.compiler.source>
<maven.compiler.target>17</maven.compiler.target>
\end{verbatim}

To have a \emph{main} method in our application and we have a main point of
execution, add the next code to the pom.xml in the section of plugins.

\begin{verbatim}
<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>exec-maven-plugin</artifactId>
  <version>1.2.1</version>
  <executions>
    <execution>
      <goals>
        <goal>java</goal>
      </goals>
    </execution>
  </executions>
  <configuration>
    <mainClass>mx.unam.concurrent.App</mainClass>
  </configuration>
</plugin>
\end{verbatim}

Thereafter we can run our project with the following instruction:

\begin{verbatim}
pwd
cd ../concurrent-example
mvn compile exec:java
\end{verbatim}

\section{Defining and starting a Thread}
\label{sec:orge4ce12b}

In Java, to use threads in our applications, we can create an instance of
the class \texttt{Thread} (\texttt{java.lang.Thread}) or make a derived subclass. Also we can
provide an object that implements the \texttt{Runnable} interface
(\texttt{java.lang.Runnable}). This interface defines a single method, \texttt{run}, meant to
contain the code executed in the thread. Lets create a basic application
where we define an instance of Thread and run it.

\begin{verbatim}
public class App {

    public static void main(String[] args) {
        MyThread1 obj1 = new MyThread1();
        MyThread2 obj2 = new MyThread2();
        Thread t = new Thread(new MyRunnable());

        obj1.start();
        obj2.start();
        t.start();
    }
}

class MyThread1 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 1 is running");
    }
}

class MyThread2 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 2 is running");
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("My runnable object is running");
    }
}
\end{verbatim}

A more interesting example could be the following:

\begin{verbatim}
package mx.unam.concurrent;

public class App {

    public static void main(String[] args) {
        MyThread1 obj1 = new MyThread1();
        MyThread2 obj2 = new MyThread2();
        Thread t = new Thread(new MyRunnable());

        obj1.start();
        obj2.start();
        t.start();
    }
}

class MyThread1 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            String output = String.format("Thread 1 is running. Iter: %d", i);
            System.out.println(output);
        }
    }
}

class MyThread2 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            String output = String.format("Thread 2 is running. Iter: %d", i);
            System.out.println(output);
        }
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            String output = String
                .format("My runnable object is running. Iter: %d", i);
            System.out.println(output);
        }
    }
}
\end{verbatim}

A possible output for the previous code is the following. We can observe how
the calls to the \texttt{println} method are interspersed. In a sequential execution,
the output of the object \texttt{obj1} should be printed (the sequence of printlns
from zero to nine) followed by the output of the \texttt{obj2} (the sequence of
printlns from zero to nine) and similarly, in the end, the output from the
object \texttt{t}, but, in this, there is not a order in how the objects are
called.

\begin{verbatim}
My runnable object is running. Iter: 0
Thread 1 is running. Iter: 0
Thread 2 is running. Iter: 0
My runnable object is running. Iter: 1
Thread 2 is running. Iter: 1
Thread 1 is running. Iter: 1
My runnable object is running. Iter: 2
Thread 2 is running. Iter: 2
Thread 1 is running. Iter: 2
My runnable object is running. Iter: 3
Thread 2 is running. Iter: 3
Thread 1 is running. Iter: 3
Thread 2 is running. Iter: 4
My runnable object is running. Iter: 4
Thread 1 is running. Iter: 4
Thread 2 is running. Iter: 5
My runnable object is running. Iter: 5
Thread 1 is running. Iter: 5
Thread 2 is running. Iter: 6
My runnable object is running. Iter: 6
Thread 1 is running. Iter: 6
Thread 2 is running. Iter: 7
My runnable object is running. Iter: 7
Thread 1 is running. Iter: 7
Thread 2 is running. Iter: 8
My runnable object is running. Iter: 8
Thread 1 is running. Iter: 8
Thread 2 is running. Iter: 9
My runnable object is running. Iter: 9
Thread 1 is running. Iter: 9
\end{verbatim}

\section{Thread managment}
\label{sec:org25b79fb}

After seeing how to use threads in a basic way, now let us discuss some
methods available to thread management. More documentation about these
methods is available on
\url{https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html}.
The methods that we refer are:

\begin{itemize}
\item start
\item suspend
\item stop
\item sleep
\item join
\end{itemize}

We will exemplify the use of the first four methods using the next program:

\begin{verbatim}
public class App {
    public static void main(String[] args) {
        MyThread t1 = new MyThread("First Thread");
        MyThread t2 = new MyThread("Second Thread");
        try {
            Thread.sleep(500); // Sleeping for 500ms
            t1.stop();
            t2.stop();
            Thread.sleep(500);
        }
        catch (InterruptedException e) {
            System.out.format("Interrupted Exception:  %s\n", e.getMessage());
            e.printStackTrace();
        }
        System.out.println("Exiting the main thread");
    }
}


class MyThread implements Runnable {
    private boolean exit;
    private String name;
    Thread t;

    public MyThread(String threadName) {
        name = threadName;
        t = new Thread(this, name);
        System.out.format("New Thread: %s\n", t.toString());
        exit = false;
        t.start(); // Starting the thread
    }

    @Override
    public void run() {
        int i = 0;
        while (!exit) {
            System.out.format("%s: %d\n", name, i);
            i++;
            try {
                Thread.sleep(100); // Sleeping for 100ms
            }
            catch (InterruptedException e) {
                System.out.format("Interrupted Exception:  %s\n", e.getMessage());
                e.printStackTrace();
            }
        }
    }

    public void stop() {
        exit = true;
    }
}
\end{verbatim}

This program declares an inner class called \texttt{MyThread}, which implements the
Runnable interface. The class constructor takes as a parameter a string,
which represents the name for the instance. Inside of the constructor, the
instance declares a thread and starts it with the method \texttt{start()}. This
method will invoke the method \texttt{run}. In this method, it will print the name of
the instance with the value of a counter. The counter will increase it every
100 milliseconds. The class \texttt{MyThread} also have a method \texttt{stop}, where we
indicating when the method \texttt{run} should stop.

Additionally, the \texttt{App} class will contain the main method. In this method, it
will declare two instances of class \texttt{MyThread} with distinct names. Then, the
main thread will do the following:

\begin{itemize}
\item sleeps by 500 milliseconds
\item calls the method \texttt{stop} of the two instances
\item and then, it sleeps for another 500 milliseconds.
\end{itemize}

A possible output for the execution of the previous code is the following:

\begin{verbatim}
New Thread: Thread[First Thread,5,main]
New Thread: Thread[Second Thread,5,main]
First Thread: 0
Second Thread: 0
Second Thread: 1
First Thread: 1
Second Thread: 2
First Thread: 2
First Thread: 3
Second Thread: 3
Second Thread: 4
First Thread: 4
Exiting the main thread
\end{verbatim}


The \texttt{join()} method allows one thread to wait until another thread completes
its execution. From Oracle's documentation:

``If \texttt{t} is a \texttt{Thread} object whose thread is currently executing, \texttt{t.join()} causes
the current thread pauses execution until \texttt{t}'s thread terminates''

Let see a more elaborated example:


\begin{verbatim}
public class SimpleThreads {

    static void threadMessage(String message) {
        String threadName = Thread.currentThread().getName();
        System.out.format("%s: %s%n", threadName, message);
    }

    private static class MessageLoop
        implements Runnable {
        public void run() {
            String importantInfo[] = {
                "Mares eat oats",
                "Does eat oats",
                "Little lambs eat ivy",
                "A kid will eat ivy too"
            };
            try {
                for (int i = 0; i < importantInfo.length; i++) {
                    Thread.sleep(4000);
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage("I wasn't done!");
            }
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        long patience = 1000 * 60 * 60;
        if (args.length > 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println("Argument must be an integer.");
                System.exit(1);
            }
        }

        threadMessage("Starting MessageLoop thread");
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage("Waiting for MessageLoop thread to finish");
        while (t.isAlive()) {
            threadMessage("Still waiting...");
            t.join(1000);
            if (((System.currentTimeMillis() - startTime) > patience)
                && t.isAlive()) {
                threadMessage("Tired of waiting!");
                t.interrupt();
                t.join();
            }
        }
        threadMessage("Finally!");
    }
}
\end{verbatim}

\section{Executors}
\label{sec:org8176f84}

Sometimes, work directly with threads could be a bit difficult and can
introduce some errors or mistakes. To avoid this, the concurrent API of java
provides a class called \texttt{ExecutorService}
(\texttt{java.util.conccurent.ExecutorService}). This class is capable of execute
asynchronous tasks and manage a pool of threads. Thus, we don't have to
create threads by hand. Also, the threads in the pool can be reused
throughout the life-cycle of our application.

The basic way to create an instance of \texttt{ExecutorService} is through the factory
class \texttt{Executors} (\texttt{java.util.concurrent.Executors}). This factory class provides
many static methods to create different instances. Variants of the
instantiated class usually are parameterized according the number of threads
or the number of cores available. An small example is shown below:

\begin{verbatim}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

public class App {

    private static void doLongWork(String name) {
        String message = String.format("Hello %s, how is going?", name);
        System.out.println(message);
        try {
            Thread.sleep(1001);
        }
        catch (InterruptedException e) {
            System.out.println("Error " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(numProcessors);
        for (int i = 0; i < numProcessors; i++) {
            final int name = i;
            executor.execute(() -> doLongWork(String.format("thread %d", name)));
        }
        executor.shutdown();
    }
}
\end{verbatim}

In the main block of the previous code, we get the number of cores (k)
available in our machine. Then, we declare an instance of ExecutorService
with a pool of k threads. Thereafter, we launch a lambda function\footnote{The lambda function is a \texttt{Runnable}. We can get the same result if we
declare a class that implements the interface and instantiate it. The instance
is passed as argument to the method \texttt{execute}.}
calling a method that it does some long work. For each core, we run the
lambda function. At the end of the program, we have to stop explicitly the
ExecutorService, if we didn't do that, the service will keep listening for
new tasks and never stops. Finally, we get a result like shown below:

\begin{verbatim}
Hello thread 0, how is going?
Hello thread 1, how is going?
Hello thread 7, how is going?
Hello thread 6, how is going?
Hello thread 2, how is going?
Hello thread 4, how is going?
Hello thread 5, how is going?
Hello thread 3, how is going?
\end{verbatim}

\subsection{Callables and Futures}
\label{sec:org3770bd6}

Similar to Runnable, executors can work with another kind of tasks. These
tasks are called callables (\texttt{Callable} interface). Such interface is similar
to \texttt{Runnable}, but instead of return void in its \texttt{run} method, it returns a
value. The Callable objects are passed to the method \texttt{submit} of the executorService

\begin{verbatim}
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class App {
    public static void main(String args[]) throws ExecutionException {
        Callable<Integer> task = () -> {
            try {
                TimeUnit.SECONDS.sleep(2);
                return 42;
            }
            catch (InterruptedException e) {
                System.out.println("Error " + e.getMessage());
                e.printStackTrace();
            }
            return -1;
        };

        try {
            ExecutorService executor = Executors.newFixedThreadPool(1);
            Future<Integer> future = executor.submit(task);
            System.out.println(String.format("Future done? %b", future.isDone()));
            Integer result = future.get();
            System.out.println(String.format("Future done? %b", future.isDone()));
            System.out.println(String.format("Result: %d", result));
            executor.shutdown();
        }
        catch (InterruptedException | ExecutionException e) {
            System.out.println("Error " + e.getMessage());
            e.printStackTrace();
        }

    }
}


\end{verbatim}














\section{Critical Sections and Isolation}
\label{sec:org8c12023}

When we implement a more complex program

\section{The concurrency package (java.util.concurrency)}
\label{sec:org48076dd}
\subsection{Locks (java.util.concurrency.locks)}
\label{sec:org21e917b}
\subsection{Atomics (java.util.concurrency.atomic)}
\label{sec:org9031850}
\subsection{Concurrent Data Structures}
\label{sec:orga655464}
\subsection{Some example}
\label{sec:orgefbddec}
\end{document}