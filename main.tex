% Created 2023-02-07 mar 16:59
% Intended LaTeX compiler: pdflatex
\documentclass{latex/classes/myarticle}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Miguel Angel Piña Avelino}
\date{\today}
\title{Introduction to multi-threading programming with Java (notes)}
\hypersetup{
 pdfauthor={Miguel Angel Piña Avelino},
 pdftitle={Introduction to multi-threading programming with Java (notes)},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.5.5)},
 pdflang={Spanish}}
\begin{document}

\maketitle
\textbf{Prerequisites to take the course}:
\begin{itemize}
\item Basic knowledge about Maven
\item An editor like emacs or vi or use an IDE like Netbeans
\item JDK 17 (open-jdk)
\item git
\end{itemize}

\section{Introduction}
\label{sec:org7917e16}

In the early 2000s, the multicore revolution began due to was difficulty
built processor chips smaller and faster. Derived from this situation, we had
to change the form we developing software. The multicore chips cause that
performs computing to be more effective by exploiting
``parallelism''. However, the challenge is in how to exploit that
parallelism. Those multicore chips (multiprocessors) usually use shared
memory to communicate the processors between themselves. An important aspect
when programming these multiprocessors is establishing coordination
mechanisms to access shared memory, for example, how to synchronize the
access to shared data to avoid problems while it is manipulated (writes and
lectures). The above is challenging because modern systems are inherently
asynchronous, and without synchronization mechanisms, unpredictable events
can occur while shared data is modified concurrently.

In this tutorial, we will focus on tools and techniques for programming
multiprocessors using shared memory with \texttt{Java}. We will cover some topics
related to concurrent and parallel computing.


\section{Processes and threads}
\label{sec:org147bb4a}

What is the difference between a process and a thread? Both process and
thread are independent sequences of execution. Loosely speaking, in practical
terms, a process is an executing program. A thread is a lightweight process
that can run over parallel with other threads and share resources as memory
and disc with its parent process. Usually, threads run in the process space
context.

For example, we can run a program in java (like Netbeans), and the
program in is known as the main process. During execution of program, it
can perform multiple events like calls to internet services or call to other
programs. Commonly, these events are performed in threads to avoid freeze the
main thread and are called asynchronously.

\section{Basics}
\label{sec:org67ad031}


\textbf{Creating the base project}: Let's create a maven based project. In a terminal,
write:

\lstset{language=bash,label= ,caption={Generating project with maven},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
cd ..
mvn archetype:generate -DgroupId=mx.unam.concurrent \
    -DartifactId=concurrent-example \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DarchetypeVersion=1.4 -DinteractiveMode=false
ls | grep concurrent-example
\end{lstlisting}

It creates a project with a main file called \texttt{App.java}. We will use that file
to write all our code for multi-threaded applications. The first thing to do
is change some parameters of our project to work with a recent java version.

In the file \texttt{pom.xml}, change the target output and compiler version. Those
values should be changed in the properties section as shown in code
\ref{org0ca0b70}.

\lstset{language=XML,label=org0ca0b70,caption={Changing content of file pom.xml},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
<maven.compiler.source>17</maven.compiler.source>
<maven.compiler.target>17</maven.compiler.target>
\end{lstlisting}

However, our application still not have defined a main class used to execute
the program. To allow this, add the code shown in code \ref{org3dbb63b} to the \texttt{pom.xml},
in the plugins section.

\lstset{language=XML,label=org3dbb63b,caption={Adding a plugin to execute directly from maven},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>exec-maven-plugin</artifactId>
  <version>1.2.1</version>
  <executions>
    <execution>
      <goals>
        <goal>java</goal>
      </goals>
    </execution>
  </executions>
  <configuration>
    <mainClass>mx.unam.concurrent.App</mainClass>
  </configuration>
</plugin>
\end{lstlisting}

We can run our project with the following instruction:

\lstset{language=bash,label= ,caption={Example of how to execute the project},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
pwd
cd ../concurrent-example
mvn compile exec:java
\end{lstlisting}


\section{Creating and starting a Thread}
\label{sec:org121ae5f}

In Java, to use threads in our applications, we can create an instance of the
class \texttt{Thread} (\texttt{java.lang.Thread}) or make a derived subclass. Also we can
provide an object that implements the \texttt{Runnable} interface
(\texttt{java.lang.Runnable}). This interface defines a single method, \texttt{run}, meant to
contain the code executed in the thread. Lets create a basic application
where we define an instance of Thread and run it.

\lstset{language=java,label= ,caption={Basic example of how to create threads},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
public class App {

    public static void main(String[] args) {
        MyThread1 obj1 = new MyThread1();
        MyThread2 obj2 = new MyThread2();
        Thread t = new Thread(new MyRunnable());

        obj1.start();
        obj2.start();
        t.start();
    }
}

class MyThread1 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 1 is running");
    }
}

class MyThread2 extends Thread {
    @Override
    public void run() {
        System.out.println("Thread 2 is running");
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("My runnable object is running");
    }
}
\end{lstlisting}

A more interesting example could be the following:

\lstset{language=java,label= ,caption={Second example of how to create threads},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
package mx.unam.concurrent;

public class App {

    public static void main(String[] args) {
        MyThread1 obj1 = new MyThread1();
        MyThread2 obj2 = new MyThread2();
        Thread t = new Thread(new MyRunnable());
        obj1.start();
        obj2.start();
        t.start();
    }
}

class MyThread1 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            String output = String.format("Thread 1 is running. Iter: %d", i);
            System.out.println(output);
        }
    }
}

class MyThread2 extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            String output = String.format("Thread 2 is running. Iter: %d", i);
            System.out.println(output);
        }
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            String output = String
                .format("My runnable object is running. Iter: %d", i);
            System.out.println(output);
        }
    }
}
\end{lstlisting}

A possible output for the previous code is the following. We can observe how
the calls to the \texttt{println} method are interspersed. In a sequential execution,
the output of the object \texttt{obj1} should be printed (the sequence of \texttt{printlns}
from zero to nine) followed by the output of the \texttt{obj2} (the sequence of
printlns from zero to nine) and similarly, in the end, the output from the
object \texttt{t}, but, in this, there is not a order in how the objects are
called.

\section{Thread managment}
\label{sec:orgd27c42d}

After seeing how to use threads in a basic way, now let us discuss some
methods available to thread management. More documentation about these
methods is available on
\url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.html}.
The methods that we refer are:

\begin{itemize}
\item start
\item suspend
\item stop
\item sleep
\item join
\end{itemize}

We will exemplify the use of the first four methods using the program shown
in the code \ref{orgcbf0778}.

\lstset{language=java,label=orgcbf0778,caption={Code example using methods for control threads.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
public class App {
    public static void main(String[] args) {
        MyThread t1 = new MyThread("First Thread");
        MyThread t2 = new MyThread("Second Thread");
        try {
            Thread.sleep(500); // Sleeping for 500ms
            t1.stop();
            t2.stop();
            Thread.sleep(500);
        }
        catch (InterruptedException e) {
            System.out.format("Interrupted Exception: %s\n",
                              e.getMessage());
            e.printStackTrace();
        }
        System.out.println("Exiting the main thread");
    }
}
class MyThread implements Runnable {
    private boolean exit;
    private String name;
    Thread t;

    public MyThread(String threadName) {
        name = threadName;
        t = new Thread(this, name);
        System.out.format("New Thread: %s\n", t.toString());
        exit = false;
        t.start(); // Starting the thread
    }

    @Override
    public void run() {
        int i = 0;
        while (!exit) {
            System.out.format("%s: %d\n", name, i);
            i++;
            try {
                Thread.sleep(100); // Sleeping for 100ms
            }
            catch (InterruptedException e) {
                System.out.format("Interrupted Exception:  %s\n",
                                  e.getMessage());
                e.printStackTrace();
            }
        }
    }

    public void stop() {
        exit = true;
    }
}
\end{lstlisting}

This program declares an inner class called \texttt{MyThread}, which implements the
Runnable interface. The class constructor takes as a parameter a string,
which represents the name for the instance. Inside of the constructor, the
instance declares a thread and starts it with the method \texttt{start()}. This
method will invoke the method \texttt{run}. In this method, it will print the name of
the instance with the value of a counter. The counter will increase it every
100 milliseconds. The class \texttt{MyThread} also have a method \texttt{stop}, where we
indicating when the method \texttt{run} should stop.

Additionally, the \texttt{App} class will contain the main method. In this method, it
will declare two instances of class \texttt{MyThread} with distinct names. Then, the
main thread will do the following:

\begin{itemize}
\item sleeps by 500 milliseconds
\item calls the method \texttt{stop} of the two instances
\item and then, it sleeps for another 500 milliseconds.
\end{itemize}

A possible output for the execution of the previous code is the following:

\begin{verbatim}
New Thread: Thread[First Thread,5,main]
New Thread: Thread[Second Thread,5,main]
First Thread: 0
Second Thread: 0
Second Thread: 1
First Thread: 1
Second Thread: 2
First Thread: 2
First Thread: 3
Second Thread: 3
Second Thread: 4
First Thread: 4
Exiting the main thread
\end{verbatim}

The \texttt{join()} method allows one thread to wait until another thread completes
its execution. From Oracle's documentation:

\begin{quote}
If \texttt{t} is a \texttt{Thread} object whose thread is currently executing, \texttt{t.join()}
causes the current thread pauses execution until \texttt{t}'s thread terminates.
\end{quote}

Let's look at a more elaborate example:

\lstset{language=java,label= ,caption={Example using \texttt{join()} method.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
public class App {

    static void threadMessage(String message) {
        String threadName = Thread.currentThread().getName();
        System.out.format("%s: %s%n", threadName, message);
    }

    private static class MessageLoop
        implements Runnable {
        public void run() {
            String importantInfo[] = {
                "Some content",
                "Another String",
                "Doing nothing",
                "I'm close to finishing"
            };
            try {
                for (int i = 0; i < importantInfo.length; i++) {
                    Thread.sleep(4000);
                    threadMessage(importantInfo[i]);
                }
            } catch (InterruptedException e) {
                threadMessage("I wasn't done!");
            }
        }
    }

    public static void main(String args[])
        throws InterruptedException {

        long patience = 1000 * 60 * 60;
        if (args.length > 0) {
            try {
                patience = Long.parseLong(args[0]) * 1000;
            } catch (NumberFormatException e) {
                System.err.println("Argument must be an integer.");
                System.exit(1);
            }
        }

        threadMessage("Starting MessageLoop thread");
        long startTime = System.currentTimeMillis();
        Thread t = new Thread(new MessageLoop());
        t.start();

        threadMessage("Waiting for MessageLoop thread to finish");
        while (t.isAlive()) {
            threadMessage("Still waiting...");
            t.join(1000);
            if (((System.currentTimeMillis() - startTime) > patience)
                && t.isAlive()) {
                threadMessage("Tired of waiting!");
                t.interrupt();
                t.join();
            }
        }
        threadMessage("Finally!");
    }
}
\end{lstlisting}

A possible output may be the following:

\begin{verbatim}
main: Starting MessageLoop thread
main: Waiting for MessageLoop thread to finish
main: Still waiting...
main: Still waiting...
main: Still waiting...
main: Still waiting...
Thread-0: Some content
main: Still waiting...
main: Still waiting...
main: Still waiting...
main: Still waiting...
Thread-0: Another String
main: Still waiting...
main: Still waiting...
main: Still waiting...
main: Still waiting...
Thread-0: Doing nothing
main: Still waiting...
main: Still waiting...
main: Still waiting...
main: Still waiting...
Thread-0: I'm close to finishing
main: Finally!
\end{verbatim}


\section{Executors}
\label{sec:orgf508d5e}

Sometimes, work directly with threads could be a bit difficult and can
introduce some errors or mistakes. To avoid this, the concurrent API of java
provides a class called \texttt{ExecutorService}
(\texttt{java.util.conccurent.ExecutorService}). This class is capable of execute
asynchronous tasks and manage a pool of threads. Thus, we don't have to
create threads by hand. Also, the threads in the pool can be reused
throughout the life-cycle of our application.

The basic way to create an instance of \texttt{ExecutorService} is through the factory
class \texttt{Executors} (\texttt{java.util.concurrent.Executors}). This factory class provides
many static methods to create different instances. Variants of the
instantiated class usually are parameterized according the number of threads
or the number of cores available. An small example is shown in the code
\ref{orgf3ccedf}.

\lstset{language=java,label=orgf3ccedf,caption={Using executors to manage threads and runnables.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

public class App {

    private static void doLongWork(String name) {
        String message = String.format("Hello %s, how is going?", name);
        System.out.println(message);
        try {
            Thread.sleep(1001);
        }
        catch (InterruptedException e) {
            System.out.println("Error " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors
            .newFixedThreadPool(numProcessors);
        for (int i = 0; i < numProcessors; i++) {
            final int name = i;
            executor.execute(() -> doLongWork(String.format("thread %d",
                                                            name)));
        }
        executor.shutdown();
    }
}
\end{lstlisting}

In the main method of the code \ref{orgf3ccedf}, we get the number of hardware
threads available in our machine. Then, we declare an instance of
ExecutorService with a pool of k threads. Thereafter, we launch a lambda
function\footnote{The lambda function is a \texttt{Runnable}. We can get the same result if we
declare a class that implements the interface and instantiate it. The instance
is passed as argument to the method \texttt{execute}.} calling a method that it does some long work. For each core,
we run the lambda function. At the end of the program, we have to stop
explicitly the ExecutorService, if we did not do that, the service will keep
listening for new tasks and never stops. Finally, we get a result like shown
below:

\begin{verbatim}
Hello thread 0, how is going?
Hello thread 1, how is going?
Hello thread 7, how is going?
Hello thread 6, how is going?
Hello thread 2, how is going?
Hello thread 4, how is going?
Hello thread 5, how is going?
Hello thread 3, how is going?
\end{verbatim}

\subsection{Callables and Futures}
\label{sec:org1ff468c}

Like Runnable, executors can work with other kinds of tasks. We called these
tasks callables (\texttt{Callable} interface). Such interface is similar to \texttt{Runnable},
but instead of returning void after calling its \texttt{run} method, it returns a
value. These objects are parameters for the method \texttt{submit} of the
executorService. This method does not wait until the task completes. The
executor service cannot return the result of the callable objecty. In that
case, the executor returns an object of type \texttt{Future}. We can retrieve the
computation result from the \texttt{Callable} object using the \texttt{Future} objects. The
\emph{futures} have a method called \texttt{isDone()}, with this method we can check if the
\emph{future} has already finished its execution. Another method available for
\emph{futures} is \texttt{get()}. Calling this method blocks the current threads and waits
until the \emph{callable} completes its execution. An example is below:


\lstset{language=java,label=org02b1557,caption={Basic example of callables and futures.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class App {
    public static void main(String args[]) throws ExecutionException {
        Callable<Integer> task = () -> {
            try {
                TimeUnit.SECONDS.sleep(2);
                return 42;
            }
            catch (InterruptedException e) {
                System.out.println("Error " + e.getMessage());
                e.printStackTrace();
            }
            return -1;
        };

        ExecutorService executor = Executors.newFixedThreadPool(1);
        try {
            Future<Integer> future = executor.submit(task);
            System.out.printf("Future done? %b\n", future.isDone());
            Integer result = future.get();
            System.out.printf("Future done? %b\n", future.isDone());
            System.out.printf("Result: %d\n", result);
            executor.shutdown();
        }
        catch (InterruptedException | ExecutionException e) {
            System.out.printf("Error %s\n", e.getMessage());
            e.printStackTrace();
            executor.shutdown();
        }
    }
}
\end{lstlisting}

\begin{verbatim}
Future done? false
Future done? true
Result: 42
\end{verbatim}



Calls to \texttt{future.get()} will block the current thread and wait until the
computation finish. But, sometimes this call can runs forever and making the
program unresponsive. To counterattack this type of scenarios, you can add a
timeout to avoid endless executions. An example below:

\lstset{language=java,label= ,caption={Adding timeouts to avoid endless executions.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class App {
    public static void main(String args[]) throws ExecutionException {
        Callable<Integer> task = () -> {
            try {
                TimeUnit.SECONDS.sleep(4);
                return 42;
            }
            catch (InterruptedException e) {
                System.out.println("Error " + e.getMessage());
                e.printStackTrace();
            }
            return -1;
        };

        ExecutorService executor = Executors.newFixedThreadPool(1);
        try {
            Future<Integer> future = executor.submit(task);
            System.out.printf("Future done? %b\n", future.isDone());
            Integer result = future.get(1, TimeUnit.SECONDS);
            System.out.printf("Future done? %b\n", future.isDone());
            System.out.printf("Result: %d\n", result);
            executor.shutdown();
        }
        catch (InterruptedException | ExecutionException
               | TimeoutException e) {
            System.out.printf("Error %s\n", e.getLocalizedMessage());
            e.printStackTrace();
            executor.shutdown();
        }
    }
}
\end{lstlisting}


The last method we will cover of ExecutorService (there are a plenty more
but we will not cover them) is \texttt{invokeAll}. \texttt{InvokeAll} allows batch submitting
of multiple \emph{callables}. This method accepts a collection of \emph{callables} and
returns a list of \emph{futures}.

\lstset{language=java,label= ,caption={Running tasks in batch},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Callable;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class App {
    public static void main(String args[]) throws ExecutionException {
        try {
            ExecutorService executor = Executors.newFixedThreadPool(1);

            List<Callable<String>> callables = Arrays
                .asList(
                        () -> {
                            TimeUnit.SECONDS.sleep(2);
                            return "task 1";
                        },
                        () -> {
                            TimeUnit.SECONDS.sleep(2);
                            return "task 2";
                        },
                        () -> {
                            TimeUnit.SECONDS.sleep(2);
                            return "task 3";
                        });

            executor.invokeAll(callables)
                .stream()
                .map(future -> {
                        try {
                            return future.get();
                        } catch (Exception e) {
                            throw new IllegalStateException(e);
                        }
                    })
                .forEach(System.out::println);
            executor.shutdown();
        }
        catch (InterruptedException e) {
            System.out.println("Error " + e.getMessage());
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

We can get better results if we increment the number of available threads
for the executorService. By example, using the previous instruction and
setting it as the fixed value:

\lstset{language=java,label= ,caption={Getting the total of hardware threads available in the machine.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
int numProcessors = Runtime.getRuntime().availableProcessors();
ExecutorService executor = Executors.newFixedThreadPool(numProcessors);
\end{lstlisting}

It is not necessary call \texttt{parallelStream} from the \textbf{Stream} API because the
\texttt{executorService} assign each task to an available thread in its pool. But,
depending on the method called (\texttt{stream} or \texttt{parallelStream}), the order of the
results may vary. This is due to stream (sequential) is pipelined in a
single thread instead of use multiple threads.


\section{Synchronized and locks}
\label{sec:orgf4bdfcf}


\subsection{Synchronized}
\label{sec:org50813be}

When we implement a more complex multithreaded program, there are sections
of code that are accessed by multiple threads. We need to pay attention when
accessing to shared mutable variable concurrently. By example, lets think in
a counter used by multiple threads concurrently. A first approach could be
the following:

\lstset{language=java,label= ,caption={Concurrent counter without synchronization},captionpos=b,numbers=none}
\begin{lstlisting}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.IntStream;

public class App {
    public static void main(String[] args) {
        Counter c = new Counter();
        c.test();
    }
}

class Counter {
    int count = 0;
    void increment() {
        count = count + 1;
    }
    public void test() {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(numProcessors);
        IntStream.range(0, 10000)
            .forEach(i -> executor.submit(this::increment));
        executor.shutdown();
        System.out.println(count);
    }
}
\end{lstlisting}

We can see that the value obtained is inconsistent with the value
expected. This happen due a race condition.  To avoid this problem, java
provides a simple mechanism to provide thread synchronization, this through
the keyword \texttt{synchronized}. Internally, Java uses a monitor lock to manage
synchronization. Let see an example:

\lstset{language=java,label= ,caption={Using the keyword \texttt{synchronized} to provide basic synchronization.},captionpos=b,numbers=none}
\begin{lstlisting}
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class App {

    public static void main(String[] args) throws InterruptedException {
        Counter c = new Counter();
        c.test();
    }
}
class Counter {
    int count = 0;
    synchronized void increment() {
        count = count + 1;
    }
    public void test() throws InterruptedException {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors
            .newFixedThreadPool(numProcessors);
        IntStream.range(0, 10000)
            .forEach(i -> executor.submit(this::increment));

        stop(executor);
        System.out.println(count);
    }

    public static void stop(ExecutorService executor) {
        try {
            executor.shutdown();
            // give it time to finish
            executor.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            if (!executor.isTerminated()) {
                System.out.println("Termination interrupted");
            }
            executor.shutdown();
        }
    }
}
\end{lstlisting}

There are more uses to the keyword synchronized, but we do not discuss them
in this tutorial.


\subsection{Locks}
\label{sec:orgf5eba2b}


Another tool provide by Java to manage synchronization are the looks. With
them, we can set lock mechanisms in an explicit way. Locks support many
methods for finer grained synchronization control. Java provides many types
of locks, by  example:
\begin{itemize}
\item \texttt{ReentrantLock},
\item \texttt{ReentrantReadWriteLock} or
\item \texttt{StampedLock}.
\end{itemize}

Locks that implement the interface \texttt{java.util.concurrent.locks.Lock}, use the
methods \texttt{lock()} and \texttt{unlock()} to provide locking explicitly. Another important
operation provided by this interface is tryLock(), used to try get the lock
without pausing the current thread. \texttt{ReentrantLock} is a class that implements
the \texttt{Lock} interface.

Let see an example:

\lstset{language=java,label= ,caption={\texttt{ReentrantLock} example.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class App {

    public static void main(String[] args) throws InterruptedException {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors
            .newFixedThreadPool(numProcessors);
        ReentrantLock lock = new ReentrantLock();
        executor.submit(() -> {
                lock.lock();
                try {
                    TimeUnit.SECONDS.sleep(4);
                    System.out.println("wake up");
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                } finally {
                    lock.unlock();
                }
            });
        executor.submit(() -> {
                System.out.printf("Locked: %b\n", lock.isLocked());
                System.out.printf("Held by me: %b\n",
                                   lock.isHeldByCurrentThread());
                boolean locked = lock.tryLock();
                System.out.printf("Lock aquired: %b\n", locked);
            });
        executor.shutdown();
    }
}
\end{lstlisting}

The class \texttt{ReentrantReadWriteLock} is another lock class that implements the
interface \texttt{ReadWriteLock}.  The idea behind is to have a pair of locks for
read-and-write access. Usually, it is safe to read mutable shared variables
while nobody is writing over them. Thus, the read-lock can be held by many
threads while no thread holds the write-lock. Using this lock, we can
improve performance and throughput when reads are more frequent than
writes. An example is below:

\lstset{language=java,label= ,caption={\texttt{ReentrantReadWriteLock} example.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.Map;
import java.util.HashMap;

public class App {

    public static void main(String[] args) throws InterruptedException {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.
            newFixedThreadPool(numProcessors);
        Map<String, String> map = new HashMap<>();
        ReadWriteLock lock = new ReentrantReadWriteLock();
        executor.submit(() -> {
                lock.writeLock().lock();
                try {
                    System.out.println("Putting information into the map");
                    TimeUnit.SECONDS.sleep(4);
                    map.put("foo", "bar");
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                } finally {
                    lock.writeLock().unlock();
                }
            });

        Runnable readTask = () -> {
            lock.readLock().lock();
            try {
                String threadName = Thread.currentThread().getName();
                System.out.printf("Name %s, value: %s\n",
                                  threadName, map.get("foo"));
                TimeUnit.SECONDS.sleep(1);
            } catch(InterruptedException ex) {
                ex.printStackTrace();
            } finally {
                lock.readLock().unlock();
            }
        };

        executor.submit(readTask);
        executor.submit(readTask);

        executor.shutdown();
    }
}
\end{lstlisting}

\section{Atomic Variables}
\label{sec:org4bf8fa4}

Java provides many classes to perform atomic operations over multiple data
types. Inside of these classes, the atomic operations are handled by
compare-and-swap or swap (getAndSet) instructions, which are atomic
instructions directly supported by most modern CPUs. These classes lives in
the package \texttt{java.util.concurrent.atomic} and some examples are:

\begin{itemize}
\item AtomicInteger
\item AtomicLong
\item AtomicReference
\item AtomicStampedReference
\item AtomicIntegerArray
\end{itemize}

The specification for the atomic accesses performed by these classes is
described in the documentation of \texttt{java.lang.invoke.VarHandle} (for java
9+). Some methods that they share are:

\begin{itemize}
\item compareAndExchange
\item compareAndSet
\item getAndIncrement
\item getAndSet
\end{itemize}

Let's see an example of how use the atomic variables:

\lstset{language=java,label= ,caption={Example of usage for \texttt{AtomicInteger}.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

public class App {

    public static void stop(ExecutorService executor) {
        try {
            executor.shutdown();
            // give it time to finish
            executor.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            if (!executor.isTerminated()) {
                System.out.println("Termination interrupted");
            }
            executor.shutdown();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors
            .newFixedThreadPool(numProcessors);
        AtomicInteger atomicInt = new AtomicInteger(0);

        IntStream.range(0, 10000)
            .forEach(i -> executor.submit(atomicInt::incrementAndGet));

        stop(executor);
        System.out.println("Value is: " + atomicInt.get());
    }
}
\end{lstlisting}


\section{Synchronizers}
\label{sec:orgb4e7d99}

Five classes aid common special purpose synchronization idioms:

\begin{description}
\item[{Semaphore}] This class is capable of maintaining whole set of
permits. Useful in scenarios where we need to limit the amount of
concurrent access to certain parts of the application. In the next example,
we define a semaphore limiting the number of concurrent accesses to the
total of available processors divided by 2 and trying execute all tasks
(the number the tasks is the number of available processors). The semaphore
limits the concurrent access only to the number defined previously. Each
task will try acquire the semaphore (trying by one second) and if it got
it, it will sleep for 5 seconds. In other case, it will print that could
not acquire the semaphore.
\end{description}

\lstset{float=*,language=java,label= ,caption={First example of synchronizers: \texttt{Semaphore}},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

public class App {
    public static void main(String[] args) throws InterruptedException {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors
            .newFixedThreadPool(numProcessors);
        Semaphore semaphore = new Semaphore(numProcessors / 2);
        Runnable longRunningTask = () -> {
            boolean permit = false;
            try {
                permit = semaphore.tryAcquire(1, TimeUnit.SECONDS);
                if (permit) {
                    System.out.println("Semaphore acquired");
                    sleep(5);
                } else {
                    System.out.println("Could not acquire semaphore");
                }
            }
            catch (InterruptedException e) {
                System.out.println("Error " + e.getMessage());
                e.printStackTrace();
            } finally {
                if (permit) {
                    semaphore.release();
                }
            }
        };
        IntStream.range(0, numProcessors)
            .forEach(i -> executor.submit(longRunningTask));
        stop(executor);
    }
    public static void stop(ExecutorService executor) {
        try {
            executor.shutdown();
            // give it time to finish
            executor.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            if (!executor.isTerminated()) {
                System.out.println("Termination interrupted");
            }
            executor.shutdown();
        }
    }
    public static void sleep(int seconds) {
        try {
            TimeUnit.SECONDS.sleep(seconds);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }
}
\end{lstlisting}


\begin{description}
\item[{CountDownLatch}] This class is a synchronization aid that allows one or
more threads to wait until a set of operations being performed in other
threads completes. From the java documentation, we have:

\begin{quote}
A \texttt{CountDownLatch} is initialized with a given \emph{count}. The await method
blocks until the current count reaches zero due to invocations of the
\texttt{countDown()} method, after which all waiting threads are released and any
subsequent invocations of await return immediately. This is a one-shot
phenomenon - count cannot be reset. If you need a version that resets the
count, consider using a CyclicBarrier.
\end{quote}
\end{description}


\lstset{language=java,label= ,caption={\texttt{CountDownLatch} example.},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class App {

    public static void main(String[] argv){
        int numProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService consumerExecutors = Executors.newFixedThreadPool(numProcessors);
        List<Message> queue = Collections.synchronizedList(new LinkedList<Message>());
        CountDownLatch doneSignal = new CountDownLatch(1);
        CountDownLatch doneProducingSignal = new CountDownLatch(1);
        CountDownLatch doneConsumingSignal = new CountDownLatch(numProcessors);
        IntStream.range(0, numProcessors)
            .forEach(i -> {
                    String name = String.format("%d", i);
                    consumerExecutors.execute(new Consumer(name, queue,
                                                           doneProducingSignal,
                                                           doneConsumingSignal));
                });
        queue.add(new Message( "1", 15000, doneSignal));
        queue.add(new Message( "2", 15000, new CountDownLatch(1)));
        doneProducingSignal.countDown();
        boolean doneProcessing = false;
        try {
            doneProcessing = doneSignal.await(3, TimeUnit.SECONDS);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        if ( doneProcessing ){
            System.out.println( "Processing is done.");
        } else {
            System.out.println( "Processing is still running.");
        }

        System.out.println( "Shutting down the consumerExecutors");
        doneProducingSignal.countDown();
        try {
            doneConsumingSignal.await();
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        consumerExecutors.shutdown();
        System.out.println( "Done");
    }
}

class Consumer implements Runnable {
    private String id;
    private List<Message> queue;
    private CountDownLatch doneProducing;
    private CountDownLatch doneConsuming;

    Consumer(String id, List<Message> queue,
             CountDownLatch doneProducing,
             CountDownLatch doneConsuming){
        this.id = id;
        this.queue = queue;
        this.doneProducing = doneProducing;
        this.doneConsuming = doneConsuming;
    }

    @Override
    public void run() {
        while(doneProducing.getCount() != 0 || !queue.isEmpty()){
            Message m = null;
            synchronized(queue){
                if(!queue.isEmpty()) m = queue.remove(0);
            }
            if(m != null) consume(m);
        }
        System.out.printf("Consumer %s done\n", id);
        doneConsuming.countDown();
    }
    public void consume(Message m ){
        System.out.printf("Consumer %s consuming message %s\n",
                          id, m.getId());
        try {
            Thread.sleep(m.getTime());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("Consumer %s done consumming msssage %s\n",
                          id, m.getId());
        m.getLatch().countDown();
    }
}

class Message {
    private String id;
    private int time;
    private CountDownLatch latch;
    Message(String id, int time, CountDownLatch latch){
        this.id = id;
        this.time = time;
        this.latch = latch;
    }
    public String getId() {
        return id;
    }
    public int getTime() {
        return time;
    }
    public CountDownLatch getLatch() {
        return latch;
    }
}

\end{lstlisting}


\begin{description}
\item[{CyclicBarrier}] This class is a synchronization aid that allows a set of
threads to all wait for each other to reach a common barrier
point. \texttt{CyclicBarriers} are useful in programs involving a fixed sized party
of threads that must occasionally wait for each other. The \texttt{barrier} is
called \texttt{cyclic} because it can reused after the waiting threads are
released. An example of use of this class is for using a barrier in a
parallel decomposition design:

\lstset{language=java,label= ,caption={CyclicBarrier example},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class App {
    public static void main(String[] args) {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        CyclicBarrier cyclicBarrier = new CyclicBarrier(numProcessors,
                                                        new CyclicTask());
        ExecutorService executor = Executors.newFixedThreadPool(numProcessors);
        System.out.println("Spawning Threads");
        IntStream.range(0, numProcessors)
            .forEach(i -> {
                    String name = String.format("Thread-%d", i);
                    executor.execute(new WorkerThread(cyclicBarrier, name));
                });
        System.out.println("Spawning Finished");
        stop(executor);
    }

    public static void stop(ExecutorService executor) {
        try {
            executor.shutdown();
            // give it time to finish
            executor.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            if (!executor.isTerminated()) {
                System.out.println("Termination interrupted");
            }
            executor.shutdown();
        }
    }
}

class WorkerThread implements Runnable {
    private CyclicBarrier cyclicBarrier;
    private String name;

    public WorkerThread(CyclicBarrier cyclicBarrier, String name) {
        this.name = name;
        this.cyclicBarrier = cyclicBarrier;
    }

    public void run() {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
            System.out.printf("%s: Doing Step 1 Work on %s\n",
                              getFormattedDate(sdf), name);
            sleep(getRandomWaitTime());
            System.out.printf("%s: Doing Step 1 more work on %s\n",
                              getFormattedDate(sdf), name);
            sleep(getRandomWaitTime());
            System.out.printf("%s: Finished Step 1 work on %s\n",
                              getFormattedDate(sdf), name);
            // Await returns for the other threads
            int count = cyclicBarrier.await();
            System.out.printf("%s: Cyclic Barrier count on %s is %d\n",
                              getFormattedDate(sdf), name, count);
            // If all threads have arrived 2 lines above, reset the barrier
            if(count == 0) {
                cyclicBarrier.reset();
            }
            System.out.printf("%s: Doing Step 2 Batch of Work on %s\n",
                              getFormattedDate(sdf), name);
            sleep(getRandomWaitTime());
            System.out.printf("%s: Doing Some more Step 2 Batch of work on %s\n",
                              getFormattedDate(sdf), name);
            sleep(getRandomWaitTime());
            System.out.printf("%s: Finished Step 2 Batch of work on %s\n",
                              getFormattedDate(sdf), name);
            count = cyclicBarrier.await();
            String template = "%s: Cyclic Barrier count end of " +
                "Step 2 Batch of work on %s is %d\n";
            System.out.printf(template, getFormattedDate(sdf), name, count);
        } catch(InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
    public static void sleep(int milliseconds) {
        try {
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }
    private String getFormattedDate(SimpleDateFormat sdf) {
        return sdf.format(new Date());
    }
    private int getRandomWaitTime() {
        return (int) ((Math.random() + 1) * 1000);
    }
}
class CyclicTask implements Runnable {
    private int count = 1;

    @Override
    public void run() {
        System.out.printf("Cyclic Barrier Finished %d\n", count++);
    }
}
\end{lstlisting}

\item[{Phaser}] This class is similar to \texttt{CyclicBarrier} and \texttt{CountDownLatch} in
functionality but supporting more flexible usage. This class allows
register tasks at any time and it permits un-registering also. Like a
\texttt{CyclicBarrier}, a \texttt{Phaser} may be repeatedly awaited for tasks synchronization
over the distinct phases. Method \texttt{arriveAndAwaitAdvance()} has effect
analogous to \texttt{CyclicBarrier.await}. With this tool also is possible
monitoring its state and determine if it terminate. Let's see an example:
\end{description}


\lstset{language=java,label= ,caption={\texttt{Phaser} example},captionpos=b,firstnumber=1,numbers=left}
\begin{lstlisting}
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Phaser;
import java.util.stream.IntStream;

public class App {
    public static void main(String[] args) {
        int numProcessors = Runtime.getRuntime().availableProcessors();
        Phaser phaser = new Phaser();
        ExecutorService executor = Executors.newFixedThreadPool(numProcessors);
        System.out.println("Spawning Threads");
        phaser.register(); // registering main thread
        IntStream.range(0, numProcessors)
            .forEach(i -> {
                    String name = String.format("Thread-%d", i);
                    executor.execute(new WorkerThread(phaser, name));
                });
        System.out.println("Spawning Finished");
        phaser.arriveAndDeregister();
        stop(executor);
    }
    public static void stop(ExecutorService executor) {
        try {
            executor.shutdown();
            // give it time to finish
            executor.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        } finally {
            if (!executor.isTerminated()) {
                System.out.println("Termination interrupted");
            }
            executor.shutdown();
        }
    }
}
class WorkerThread implements Runnable {
    private Phaser phaser;
    private String name;
    public WorkerThread(Phaser phaser, String name) {
        this.name = name;
        this.phaser = phaser;
        this.phaser.register();
    }
    public void run() {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
        System.out.printf("%s:[%s] Doing Step 1 Work\n",
                          getFormattedDate(sdf), name);
        sleep(getRandomWaitTime());
        System.out.printf("%s:[%s] Doing Step 1 more work\n",
                          getFormattedDate(sdf), name);
        sleep(getRandomWaitTime());
        System.out.printf("%s:[%s] Finished Step 1 work\n",
                          getFormattedDate(sdf), name);
        phaser.arriveAndAwaitAdvance();
        System.out.printf("%s:[%s] Past the barrier.\n",
                          getFormattedDate(sdf), name);
        int phase = phaser.getPhase();
        // here we had a reset with CyclicBarrier
        System.out.printf("%s:[%s] Phaser count on %d\n",
                          getFormattedDate(sdf), name, phase);
        System.out.printf("%s:[%s] Doing Step 2 Batch of Work\n",
                          getFormattedDate(sdf), name);
        sleep(getRandomWaitTime());
        System.out.printf("%s:[%s] Doing Some more Step 2 Batch of work\n",
                          getFormattedDate(sdf), name);
        sleep(getRandomWaitTime());
        System.out.printf("%s:[%s] Finished Step 2 Batch of work\n",
                          getFormattedDate(sdf), name);
        phaser.arriveAndAwaitAdvance();
        phase = phaser.getPhase();
        System.out.printf("%s:[%s] Phaser finish on: %d\n",
                          getFormattedDate(sdf), name, phase);
    }
    public static void sleep(int milliseconds) {
        try {
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            throw new IllegalStateException(e);
        }
    }
    private String getFormattedDate(SimpleDateFormat sdf) {
        return sdf.format(new Date());
    }
    private int getRandomWaitTime() {
        return (int) ((Math.random() + 1) * 1000);
    }
}
\end{lstlisting}

\begin{description}
\item[{Exchanger}] A synchronization point at which threads can pair and swap
elements within pairs. Each thread presents some object on entry to the
\texttt{exchange} method, matches with a partner thread, and receives its partner's
object on return. An \texttt{Exchanger} may be viewed as a bidirectional form of a
\texttt{SynchronousQueue}. \texttt{Exchangers} may be useful in applications such as genetic
algorithms and pipeline designs.
\end{description}

Just to finish this section, an interesting comment taken from stackoverflow
about real-life examples for use CountDownLatch, Semaphores, Mutex and
CyclicBarriers is the following:

\begin{quote}
In a hypothetical theater:

\begin{itemize}
\item It is called \textbf{Mutex} if only one person is allowed to watch the play.
\item It is called \textbf{Semaphore} if N number of people are allowed to watch the
play. If anybody leaves the Theater during the play then other person can
be allowed to watch the play.
\item It is called \textbf{CountDownLatch} if no one is allowed to enter until every
person vacates the theater. Here each person has free will to leave the
theater.
\item It is called \textbf{CyclicBarrier} if the play will not start until every person
enters the theater. Here a showman can not start the show until all the
persons enter and grab the seat. Once the play is finished the same barrier
will be applied for next show.
\end{itemize}

Here, a person is a thread, a play is a resource.
\end{quote}

\section{VarHandle}
\label{sec:orgc0b140a}

\texttt{VarHandle} (\texttt{java.lang.invoke.VarHandle}) is a class that provides low-level
mechanisms and APIs for method invocations and memory operations. The goal of
this class is replace the operations in \texttt{sun.misc.Unsafe}, used in Java version
less than 9 but with a safe equivalent. It provides access to variables under
various access modes, including plain read/write access, volatile read/write
access and compare-and-set. Additionally, it provides a set of static methods
referred to as memory fence methods for fine-grained control of memory
ordering. The specification of language permits other threads observe
operations as if they were executed in orders different than are apparent in
program source code, subject to constraint arising. The methods \texttt{fullFence},
\texttt{acquireFence}, \texttt{releaseFence}, \texttt{loadLoadFence} and \texttt{storeStoreFence}, can be used to
impose constraints.


\section{References}
\label{sec:org07c446a}

\begin{itemize}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/invoke/VarHandle.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CyclicBarrier.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ExecutorService.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Executors.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Phaser.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Semaphore.html}
\item \url{https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/CountDownLatch.html}
\item \url{https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/}
\item \url{https://winterbe.com/posts/2015/04/30/java8-concurrency-tutorial-synchronized-locks-examples/}
\item \url{https://winterbe.com/posts/2015/05/22/java8-concurrency-tutorial-atomic-concurrent-map-examples/}
\item \url{https://stackoverflow.com/questions/10156191/real-life-examples-for-countdownlatch-and-cyclicbarrier/32416323\#32416323}
\item \url{http://oliviertech.com/es/java/CountDownLatch-java-example/}
\end{itemize}
\end{document}